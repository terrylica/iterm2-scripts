# ruff: noqa: F821
# ADR: docs/adr/2026-01-26-modular-source-concatenation.md
# This module is concatenated with _header.py - imports come from there

# =============================================================================
# First-Run Detection and Wizard
# =============================================================================


def is_first_run() -> bool:
    """
    Detect if this is the first run for a new user.

    Returns True if:
    - No layout-*.toml files exist in CONFIG_DIR
    - No legacy layout.toml exists
    - No selector-preferences.toml exists

    Returns:
        True if this appears to be a first-time run
    """
    # Check for any layout files
    layout_files = list(CONFIG_DIR.glob(LAYOUT_PATTERN))
    if layout_files:
        return False

    # Check for legacy layout.toml
    legacy_layout = CONFIG_DIR / "layout.toml"
    if legacy_layout.exists():
        return False

    # Check for preferences (indicates previous use)
    if PREFERENCES_PATH.exists():
        return False

    logger.debug(
        "First-run detected",
        operation="is_first_run",
        config_dir=str(CONFIG_DIR),
        layout_files_count=0
    )
    return True


def generate_default_layout_content(home_dir: bool = True, project_dir: str | None = None) -> str:
    """
    Generate default layout TOML content.

    Args:
        home_dir: Include home directory tab
        project_dir: Optional project directory to include

    Returns:
        TOML content string
    """
    lines = [
        "# iTerm2 Layout Manager Configuration",
        "# Auto-generated by first-run wizard",
        "# Edit this file to customize your workspace tabs",
        "",
        "[layout]",
        "left_pane_ratio = 0.25",
        "settle_time = 0.3",
        "",
        "[commands]",
        "# Safe defaults - customize after verifying tool availability",
        'left = "ls -la"    # Try: br --sort-by-type-dirs-first (requires broot)',
        'right = "zsh"      # Try: css (requires Claude Code)',
        "",
    ]

    if home_dir:
        lines.extend([
            "[[tabs]]",
            'name = "home"',
            'dir = "~"',
            "",
        ])

    if project_dir:
        # Convert to ~ format if in home directory
        home = str(Path.home())
        if project_dir.startswith(home):
            project_dir = "~" + project_dir[len(home):]

        project_name = Path(project_dir).name
        lines.extend([
            "[[tabs]]",
            f'name = "{project_name}"',
            f'dir = "{project_dir}"',
            "",
        ])

    return "\n".join(lines)


async def run_first_run_wizard(connection, window) -> bool:
    """
    Run the first-run wizard for new users.

    Presents a minimal 2-3 step wizard to:
    1. Welcome and explain the tool
    2. Optionally add a project directory
    3. Create default config

    Args:
        connection: iTerm2 connection
        window: Current iTerm2 window

    Returns:
        True if wizard completed successfully, False if cancelled
    """
    logger.info(
        "Starting first-run wizard",
        operation="run_first_run_wizard",
        status="started"
    )

    # Step 1: Welcome dialog
    welcome_alert = iterm2.Alert(
        "Welcome to iTerm2 Layout Manager",
        "This tool creates workspace tabs with split panes on startup.\n\n"
        "Each tab has:\n"
        "• Left pane: File browser (narrow)\n"
        "• Right pane: Main workspace (wide)\n\n"
        "Let's set up your first layout.",
        window_id=window.window_id
    )
    welcome_alert.add_button("Get Started")
    welcome_alert.add_button("Cancel")
    response = await welcome_alert.async_run(connection)

    if response == 1:  # Cancel
        logger.info(
            "First-run wizard cancelled at welcome",
            operation="run_first_run_wizard",
            status="cancelled"
        )
        return False

    # Step 2: Ask about project directory
    folder_alert = iterm2.Alert(
        "Add Project Folder",
        "Would you like to add a project folder?\n\n"
        "You can always add more folders later via the Settings dialog.",
        window_id=window.window_id
    )
    folder_alert.add_button("Add Folder")
    folder_alert.add_button("Skip")
    folder_alert.add_button("Cancel")
    response = await folder_alert.async_run(connection)

    if response == 2:  # Cancel
        logger.info(
            "First-run wizard cancelled at folder selection",
            operation="run_first_run_wizard",
            status="cancelled"
        )
        return False

    project_dir = None
    if response == 0:  # Add Folder
        project_dir = choose_folder_native("Select your project folder:")
        if project_dir:
            logger.debug(
                "Project folder selected",
                operation="run_first_run_wizard",
                folder=project_dir
            )

    # Step 3: Create config file
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)

    layout_content = generate_default_layout_content(
        home_dir=True,
        project_dir=project_dir
    )

    layout_path = CONFIG_DIR / "layout-default.toml"

    try:
        atomic_write_file(layout_path, layout_content)

        logger.info(
            "First-run wizard completed - layout created",
            operation="run_first_run_wizard",
            status="success",
            layout_path=str(layout_path)
        )

        # Show completion message
        complete_alert = iterm2.Alert(
            "Setup Complete!",
            f"Your layout config has been created:\n"
            f"{layout_path}\n\n"
            "Edit this file to add more workspace tabs.\n\n"
            "Optional enhancements:\n"
            "• brew install broot (file navigator)\n"
            "• brew install swiftdialog (better UI)",
            window_id=window.window_id
        )
        complete_alert.add_button("OK")
        await complete_alert.async_run(connection)

        return True

    except OSError as e:
        logger.error(
            "Failed to create layout file in wizard",
            operation="run_first_run_wizard",
            status="failed",
            error=str(e)
        )

        error_alert = iterm2.Alert(
            "Setup Failed",
            f"Could not create config file:\n{e}\n\n"
            f"Please create manually:\n{layout_path}",
            window_id=window.window_id
        )
        error_alert.add_button("OK")
        await error_alert.async_run(connection)

        return False


async def run_setup_wizard_for_veteran(connection, window) -> bool:
    """
    Run setup wizard for veteran users (manual trigger).

    Unlike first-run wizard, this creates a new layout file with a unique name
    (layout-wizard-generated.toml) without overwriting existing configs.

    Args:
        connection: iTerm2 connection
        window: Current iTerm2 window

    Returns:
        True if wizard completed successfully, False if cancelled
    """
    logger.info(
        "Starting setup wizard (veteran user)",
        operation="run_setup_wizard_for_veteran",
        status="started"
    )

    # Step 1: Inform user about the wizard
    info_alert = iterm2.Alert(
        "Setup Wizard",
        "This wizard will create a new layout configuration file.\n\n"
        "Your existing layouts will not be modified.\n"
        "The new file will be named: layout-wizard-generated.toml",
        window_id=window.window_id
    )
    info_alert.add_button("Continue")
    info_alert.add_button("Cancel")
    response = await info_alert.async_run(connection)

    if response == 1:  # Cancel
        logger.info(
            "Veteran wizard cancelled",
            operation="run_setup_wizard_for_veteran",
            status="cancelled"
        )
        return False

    # Step 2: Ask about project directory
    folder_alert = iterm2.Alert(
        "Add Project Folder",
        "Would you like to add a project folder to the new layout?",
        window_id=window.window_id
    )
    folder_alert.add_button("Add Folder")
    folder_alert.add_button("Skip")
    folder_alert.add_button("Cancel")
    response = await folder_alert.async_run(connection)

    if response == 2:  # Cancel
        logger.info(
            "Veteran wizard cancelled at folder selection",
            operation="run_setup_wizard_for_veteran",
            status="cancelled"
        )
        return False

    project_dir = None
    if response == 0:  # Add Folder
        project_dir = choose_folder_native("Select your project folder:")

    # Step 3: Create config file
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)

    layout_content = generate_default_layout_content(
        home_dir=True,
        project_dir=project_dir
    )

    layout_path = CONFIG_DIR / "layout-wizard-generated.toml"

    try:
        atomic_write_file(layout_path, layout_content)

        logger.info(
            "Veteran wizard completed - layout created",
            operation="run_setup_wizard_for_veteran",
            status="success",
            layout_path=str(layout_path)
        )

        # Show completion message
        complete_alert = iterm2.Alert(
            "Layout Created!",
            f"New layout saved to:\n{layout_path}\n\n"
            "Select it from the layout list to use it.",
            window_id=window.window_id
        )
        complete_alert.add_button("OK")
        await complete_alert.async_run(connection)

        return True

    except OSError as e:
        logger.error(
            "Failed to create layout file in veteran wizard",
            operation="run_setup_wizard_for_veteran",
            status="failed",
            error=str(e)
        )

        error_alert = iterm2.Alert(
            "Setup Failed",
            f"Could not create config file:\n{e}",
            window_id=window.window_id
        )
        error_alert.add_button("OK")
        await error_alert.async_run(connection)

        return False


async def show_layout_selector(connection, layouts: list[dict]) -> dict | None:
    """
    Show layout selection dialog and return chosen layout.

    Args:
        connection: iTerm2 connection object
        layouts: List of layout dicts from discover_layouts()

    Returns:
        Selected layout dict, or None if cancelled/no layouts
    """
    if not layouts:
        logger.error(
            "No layouts available to select",
            operation="show_layout_selector",
            status="failed"
        )
        return None

    # Single layout - use directly without dialog
    if len(layouts) == 1:
        logger.debug(
            "Single layout found, using directly",
            operation="show_layout_selector",
            status="single",
            layout_name=layouts[0]["name"]
        )
        return layouts[0]

    # Build alert with layout buttons
    logger.debug(
        "Showing selector dialog",
        operation="show_layout_selector",
        status="started",
        metrics={"layouts_count": len(layouts)}
    )

    alert = iterm2.Alert(
        title="Select Layout",
        subtitle="Choose a workspace layout to load:",
    )

    # Add button for each layout (in discovery order)
    for layout in layouts:
        alert.add_button(layout["display"])
        logger.debug(
            "Added button to dialog",
            operation="show_layout_selector",
            layout_display=layout["display"]
        )

    # Add Settings button (for directory management)
    alert.add_button("Settings...")

    # Add Setup Wizard button (for veteran users to re-run wizard)
    alert.add_button("Setup Wizard...")

    # Add Cancel button at the end
    alert.add_button("Cancel")

    # Show dialog and get result
    try:
        result = await alert.async_run(connection)

        # CRITICAL: Restore focus after dialog closes
        # The modal dialog may have caused focus to shift away from iTerm2
        app = await iterm2.async_get_app(connection)
        if app:
            await app.async_activate()  # Bring iTerm2 to foreground
            logger.debug(
                "Restored app focus after dialog",
                operation="show_layout_selector"
            )

        logger.debug(
            "Dialog result received",
            operation="show_layout_selector",
            result_raw=result
        )

        # Result is 1000 + button_index
        button_index = result - 1000

        logger.debug(
            "Button index calculated",
            operation="show_layout_selector",
            button_index=button_index
        )

        # Check if Settings was clicked
        if button_index == len(layouts):
            logger.debug(
                "Settings clicked",
                operation="show_layout_selector",
                status="settings"
            )
            # Return special action dict
            return {"action": "manage_directories"}

        # Check if Setup Wizard was clicked
        if button_index == len(layouts) + 1:
            logger.debug(
                "Setup Wizard clicked",
                operation="show_layout_selector",
                status="wizard"
            )
            # Return special action dict
            return {"action": "run_wizard"}

        # Check if Cancel was clicked (last button)
        if button_index > len(layouts) + 1:
            logger.debug(
                "Cancel clicked or invalid selection",
                operation="show_layout_selector",
                status="cancelled"
            )
            return None

        selected = layouts[button_index]
        logger.debug(
            "Layout selected",
            operation="show_layout_selector",
            status="success",
            layout_name=selected["name"]
        )

        return selected

    except (iterm2.RPCException, ValueError, TypeError) as e:
        logger.error(
            "Dialog error occurred",
            operation="show_layout_selector",
            status="failed",
            error=str(e),
            error_type=type(e).__name__
        )
        return None


# =============================================================================
# Alpha-Forge Worktree Detection (Optional)
# ADR: cc-skills/docs/adr/2025-12-14-alpha-forge-worktree-management.md
# =============================================================================


def extract_slug(worktree_path: str, prefix: str) -> str:
    """
    Extract slug from worktree path.

    Example: alpha-forge.worktree-2025-12-14-sharpe-statistical-validation
             → sharpe-statistical-validation
    """
    basename = os.path.basename(worktree_path)
    # Remove prefix (e.g., "alpha-forge.worktree-")
    if basename.startswith(prefix):
        remainder = basename[len(prefix):]
        # Remove date: YYYY-MM-DD-
        parts = remainder.split("-", 3)
        if len(parts) >= 4:
            return parts[3]  # slug after date
        return remainder
    return basename


def generate_acronym(slug: str) -> str:
    """
    Generate acronym from slug words.

    Example: sharpe-statistical-validation → ssv
    """
    words = slug.split("-")
    return "".join(word[0].lower() for word in words if word)


def discover_worktrees(config: dict) -> list[dict]:
    """
    Discover git worktrees dynamically based on config.

    Args:
        config: Configuration dict with worktrees section

    Returns:
        List of tab configs: [{"name": "AF-ssv", "dir": "/path/to/worktree"}]
    """
    worktree_config = config.get("worktrees", {})
    root = worktree_config.get("alpha_forge_root")

    # Worktree discovery disabled if no root configured
    if not root:
        return []

    root = os.path.expanduser(root)
    if not os.path.isdir(root):
        return []

    # Get pattern from config or derive from root basename
    pattern = worktree_config.get("worktree_pattern")
    if not pattern:
        # Derive pattern from root: ~/eon/alpha-forge → alpha-forge.worktree-*
        root_name = os.path.basename(root)
        pattern = f"{root_name}.worktree-*"

    # Build glob pattern in parent directory
    parent_dir = os.path.dirname(root)
    glob_pattern = os.path.join(parent_dir, pattern)
    candidates = glob.glob(glob_pattern)

    if not candidates:
        return []

    # Validate with git worktree list
    try:
        result = subprocess.run(
            ["git", "worktree", "list"],
            cwd=root,
            capture_output=True,
            text=True,
            timeout=5,
            check=False,  # Handle non-zero returncode explicitly below
        )
        if result.returncode != 0:
            logger.warning(
                "Git worktree list failed",
                operation="discover_worktrees",
                status="failed",
                root=root,
                returncode=result.returncode,
                stderr=result.stderr.strip() if result.stderr else None
            )
            return []

        # Parse valid worktree paths from output
        valid_paths = set()
        for line in result.stdout.strip().split("\n"):
            if line:
                # Format: /path/to/worktree  abc1234 [branch-name]
                parts = line.split()
                if parts:
                    valid_paths.add(parts[0])
    except subprocess.TimeoutExpired:
        logger.error(
            "Git worktree list timed out",
            operation="discover_worktrees",
            status="timeout",
            root=root,
            timeout_seconds=5
        )
        return []
    except FileNotFoundError:
        logger.error(
            "Git command not found",
            operation="discover_worktrees",
            status="git_not_found",
            root=root
        )
        return []

    # Filter and generate tab configs
    # Derive prefix for slug extraction (e.g., "alpha-forge.worktree-")
    root_name = os.path.basename(root)
    prefix = f"{root_name}.worktree-"

    tabs = []
    for path in sorted(candidates):
        if path in valid_paths:
            slug = extract_slug(path, prefix)
            acronym = generate_acronym(slug)
            # Use root basename for tab prefix (e.g., "AF" for alpha-forge)
            tab_prefix = "".join(word[0].upper() for word in root_name.split("-") if word)
            tabs.append({"name": f"{tab_prefix}-{acronym}", "dir": path})

    return tabs


# =============================================================================
# Universal Worktree Detection (All Git Repos)
# =============================================================================


def get_enabled_scan_directories(prefs: dict) -> list[Path]:
    """
    Get list of enabled scan directories from preferences.

    Args:
        prefs: Preferences dict with scan_directories key

    Returns:
        List of Path objects for enabled directories
    """
    scan_dirs = prefs.get("scan_directories", DEFAULT_SCAN_DIRECTORIES)
    enabled_dirs = []

    for scan_dir in scan_dirs:
        if scan_dir.get("enabled", True):
            path = Path(scan_dir["path"]).expanduser()
            enabled_dirs.append(path)

    return enabled_dirs


def discover_git_repos(
    scan_directories: list[Path] | None = None,
    exclude_dirs: set[Path] | None = None
) -> list[dict]:
    """
    Find git repositories in discovery directories.

    Args:
        scan_directories: List of directories to scan (from preferences)
        exclude_dirs: Set of paths to exclude (optional)

    Returns:
        List of dicts: {"name": "repo-name", "dir": "/path/to/repo"}
    """
    start_time = time.perf_counter()

    # Use empty list if not specified (portability - no hardcoded paths)
    if scan_directories is None:
        scan_directories = []

    if exclude_dirs is None:
        exclude_dirs = set()

    repos = []
    op_trace_id = str(uuid4())

    logger.debug(
        "Starting git repo discovery",
        operation="discover_git_repos",
        status="started",
        trace_id=op_trace_id,
        discovery_dirs=[str(d) for d in scan_directories]
    )

    for base_dir in scan_directories:
        if not base_dir.exists():
            logger.debug(
                "Discovery directory does not exist",
                operation="discover_git_repos",
                trace_id=op_trace_id,
                directory=str(base_dir)
            )
            continue

        for child in base_dir.iterdir():
            if not child.is_dir():
                continue
            if child in exclude_dirs:
                continue

            git_path = child / ".git"
            if not git_path.exists():
                continue
            # Skip git worktrees - they have .git as a file, not directory
            # Worktrees are discovered separately by discover_all_worktrees()
            if not git_path.is_dir():
                continue

            repos.append({
                "name": child.name,
                "dir": str(child)
            })

    duration_ms = int((time.perf_counter() - start_time) * 1000)
    logger.debug(
        "Git repo discovery complete",
        operation="discover_git_repos",
        status="success",
        trace_id=op_trace_id,
        metrics={"repos_found": len(repos), "duration_ms": duration_ms}
    )

    return sorted(repos, key=lambda x: x["name"])


def discover_untracked_folders(
    scan_directories: list[Path] | None = None,
    exclude_dirs: set[Path] | None = None
) -> list[dict]:
    """
    Find directories that are NOT git repositories (untracked folders).

    These are directories that exist but don't have a .git folder - potentially
    new projects not yet initialized with git.

    Args:
        scan_directories: List of directories to scan (from preferences)
        exclude_dirs: Set of paths to exclude (optional)

    Returns:
        List of dicts: {"name": "folder-name", "dir": "/path/to/folder"}
    """
    start_time = time.perf_counter()

    # Use empty list if not specified (portability - no hardcoded paths)
    if scan_directories is None:
        scan_directories = []

    if exclude_dirs is None:
        exclude_dirs = set()

    folders = []
    op_trace_id = str(uuid4())

    logger.debug(
        "Starting untracked folder discovery",
        operation="discover_untracked_folders",
        status="started",
        trace_id=op_trace_id,
        discovery_dirs=[str(d) for d in scan_directories]
    )

    for base_dir in scan_directories:
        if not base_dir.exists():
            continue

        for child in base_dir.iterdir():
            if not child.is_dir():
                continue
            if child in exclude_dirs:
                continue
            # Skip hidden directories
            if child.name.startswith("."):
                continue

            git_path = child / ".git"
            # Only include if .git does NOT exist (not a repo, not a worktree)
            if git_path.exists():
                continue

            folders.append({
                "name": child.name,
                "dir": str(child)
            })

    duration_ms = int((time.perf_counter() - start_time) * 1000)
    logger.debug(
        "Untracked folder discovery complete",
        operation="discover_untracked_folders",
        status="success",
        trace_id=op_trace_id,
        metrics={"folders_found": len(folders), "duration_ms": duration_ms}
    )

    return sorted(folders, key=lambda x: x["name"])


def discover_all_worktrees(git_repos: list[dict]) -> list[dict]:
    """
    Discover git worktrees from ALL git repositories.

    Scans each git repo and returns any worktrees found (excluding main worktree).

    Args:
        git_repos: List of dicts with "name" and "dir" keys (from discover_git_repos)

    Returns:
        List of dicts: {"name": "repo.wt-branch", "dir": "/path/to/worktree", "parent": "repo-name"}
    """
    start_time = time.perf_counter()
    discovered = []
    op_trace_id = str(uuid4())

    logger.debug(
        "Starting universal worktree discovery",
        operation="discover_all_worktrees",
        status="started",
        trace_id=op_trace_id,
        metrics={"repos_to_scan": len(git_repos)}
    )

    for repo in git_repos:
        repo_path = Path(repo["dir"]).expanduser()
        if not repo_path.exists():
            logger.debug(
                "Skipping non-existent repo path",
                operation="discover_all_worktrees",
                trace_id=op_trace_id,
                repo=repo["name"],
                path=str(repo_path)
            )
            continue

        try:
            result = subprocess.run(
                ["git", "worktree", "list", "--porcelain"],
                cwd=repo_path,
                capture_output=True,
                text=True,
                check=True,
                timeout=10  # Prevent hanging on slow filesystems
            )

            # Parse porcelain output
            # Format: worktree /path\nHEAD sha\nbranch refs/heads/name\n\n
            # OR for detached: worktree /path\nHEAD sha\ndetached\n\n
            current_worktree = {}
            is_prunable = False

            for line in result.stdout.split("\n"):
                if line.startswith("worktree "):
                    # Save previous worktree if valid
                    if current_worktree and current_worktree.get("name") and not is_prunable:
                        discovered.append(current_worktree)
                    # Reset for new worktree
                    current_worktree = {}
                    is_prunable = False

                    wt_path = Path(line[9:])  # Remove "worktree " prefix
                    # Skip main worktree (same as repo path)
                    if wt_path.resolve() == repo_path.resolve():
                        current_worktree = {}  # Reset, don't save main
                        continue
                    # Skip if directory doesn't exist
                    if not wt_path.is_dir():
                        current_worktree = {}
                        continue
                    current_worktree = {
                        "dir": str(wt_path),
                        "parent": repo["name"]
                    }
                elif line.startswith("branch "):
                    branch = line.split("/")[-1]  # refs/heads/feature -> feature
                    if current_worktree:
                        # Name format: RepoAbbrev.wt-branch
                        abbrev = repo["name"][:2].upper()
                        current_worktree["name"] = f"{abbrev}.wt-{branch}"
                elif line == "detached":
                    # Handle detached HEAD worktrees
                    if current_worktree:
                        abbrev = repo["name"][:2].upper()
                        # Use directory name for detached worktrees
                        dir_name = Path(current_worktree["dir"]).name
                        current_worktree["name"] = f"{abbrev}.wt-{dir_name}"
                        current_worktree["detached"] = True
                elif line.startswith("prunable"):
                    # Skip prunable worktrees (missing directory)
                    is_prunable = True

            # Don't forget last worktree
            if current_worktree and current_worktree.get("name") and not is_prunable:
                discovered.append(current_worktree)

        except subprocess.CalledProcessError as e:
            logger.warning(
                "Failed to list worktrees for repo",
                operation="discover_all_worktrees",
                status="failed",
                trace_id=op_trace_id,
                repo=repo["name"],
                error=str(e.stderr) if e.stderr else "unknown"
            )
            continue
        except subprocess.TimeoutExpired:
            logger.warning(
                "Timeout listing worktrees for repo",
                operation="discover_all_worktrees",
                status="timeout",
                trace_id=op_trace_id,
                repo=repo["name"]
            )
            continue

    # Deduplicate by directory path (same worktree can be found from multiple repos)
    seen_dirs = set()
    unique_worktrees = []
    for wt in discovered:
        wt_dir = Path(wt["dir"]).resolve()
        if wt_dir not in seen_dirs:
            seen_dirs.add(wt_dir)
            unique_worktrees.append(wt)

    duration_ms = int((time.perf_counter() - start_time) * 1000)
    logger.debug(
        "Universal worktree discovery complete",
        operation="discover_all_worktrees",
        status="success",
        trace_id=op_trace_id,
        metrics={
            "worktrees_found": len(unique_worktrees),
            "duplicates_removed": len(discovered) - len(unique_worktrees),
            "duration_ms": duration_ms
        }
    )

    return unique_worktrees

